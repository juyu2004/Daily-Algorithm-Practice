# DAY33 - 20250802

## 划分字母区间 

核心思路

记录字符最后位置：

遍历字符串，用数组 hash 记录每个字符最后一次出现的索引。

动态维护区间边界：

再次遍历字符串，维护当前区间的起始点 start 和最远边界 end。

end 为当前字符的最后位置与之前 end 的较大值。

当遍历到 end 时，说明当前区间内所有字符的最后出现位置都在该区间内，可完成划分。

```C++
#include <vector>
#include <iostream>
using namespace std;

class Solution 
{
    int hash[26] = {0};  // 存储每个小写字母的最后出现位置（索引）
public:
    vector<int> partitionLabels(string s) 
    {
        vector<int> ret;  // 存储划分结果的长度

        // 第一遍遍历：记录每个字符的最后出现位置
        for(int i = 0; i < s.size(); i++)
            hash[s[i] - 'a'] = i;  // 'a'-'a'=0，'b'-'a'=1，依此类推

        // 第二遍遍历：动态划分区间
        int end = -1, start = 0;  // end初始化为-1，确保第一个字符能更新end
        for(int i = 0; i < s.size(); i++)
        {
            // 更新当前区间的最远边界：取当前字符的最后位置与之前end的较大值
            end = max(end, hash[s[i] - 'a']);

            // 当遍历到end时，说明当前区间内所有字符的最后位置都在[i,end]内
            if(end == i)
            {
                ret.push_back(end - start + 1);  // 记录当前区间长度
                start = end + 1;  // 更新下一个区间的起始位置
            }
        }
        return ret;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/partition-labels/solutions/3737691/hua-fen-zi-mu-qu-jian-c-by-wu-guan-feng-521wr/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 找到字符串中所有字母异位词

哈希表统计字符频率：

hash_p：统计字符串p中每个字符的出现次数。

hash_s：动态统计当前滑动窗口中每个字符的出现次数。

滑动窗口维护：

窗口大小固定为p的长度k。

右指针right不断向右扩展，左指针left在窗口达到k大小时同步右移，保持窗口大小不变。

异位词判断：

当窗口大小等于k时，比较hash_s与hash_p是否完全相同。若相同，则当前窗口是p的异位词。

```C++
class Solution 
{
    int hash_p[26] = {0};  // 统计p中字符频率
    int hash_s[26] = {0};  // 统计当前窗口中字符频率
public:
    vector<int> findAnagrams(string s, string p) 
    {
        vector<int> ret;
        int k = p.size();
        // 初始化hash_p：统计p中每个字符的出现次数
        for(int i = 0; i < k; i++) 
            hash_p[p[i] - 'a']++;

        int left = 0, right = 0;
        while(right < s.size())
        {
            // 1. 扩大窗口：将right指向的字符加入窗口
            hash_s[s[right] - 'a']++;
            
            // 2. 判断窗口大小是否达到k
            if(right - left + 1 == k)
            {
                // 3. 窗口达到k大小，检查是否为异位词
                if(judge(hash_p, hash_s)) 
                    ret.push_back(left);
                
                // 4. 收缩窗口：移除left指向的字符
                hash_s[s[left] - 'a']--;
                left++;
            }
            right++;
        }
        return ret;
    }

    // 辅助函数：判断两个哈希表是否完全相同
    bool judge(int* a, int* b)
    {
        for(int i = 0; i < 26; i++)
            if(a[i] != b[i]) return false;
        return true;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/3737726/zhao-dao-zi-fu-chuan-zhong-suo-you-zi-mu-tdkj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## kotori和气球

```C++
#include <iostream>

using namespace std;
int n, m;
const int mod = 109;

int main()
{
    cin >> n >> m;
    int ret = n;
    for(int i = 0; i < m - 1; i++)
        ret = ret * (n - 1) % mod;
    
    cout << ret << endl;
    return 0;
}
```

简单的排列组合，结果等于n与m个n-1的乘积。  

## 走迷宫

题目连接：https://www.nowcoder.com/practice/e88b41dc6e764b2893bc4221777ffe64?tpId=308&tqId=40477&ru=/exam/oj

```C++
#include <iostream>
#include <queue>
using namespace std;

const int N = 1010;
char nums[N][N];
int idx[4] = {0, 0, 1, -1};  // 四个方向偏移量
int idy[4] = {1, -1, 0, 0};
bool vis[N][N] = {false};    // 访问标记
int cnt[N][N];               // 记录到每个位置的步数

int main() 
{
    int n, m, x1, y1, x2, y2;
    cin >> n >> m >> x1 >> y1 >> x2 >> y2;
    
    // 输入迷宫（坐标从1开始）
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> nums[i][j];
    
    // 检查起点是否为障碍
    if(nums[x1][y1] == '*') {
        cout << -1 << endl;
        return 0;
    }

    queue<pair<int, int>> q;
    q.push({x1, y1});
    vis[x1][y1] = true;  // 正确标记起点为已访问
    cnt[x1][y1] = 0;     // 初始化起点步数为0

    while(!q.empty())
    {
        int sz = q.size();
        for(int i = 0; i < sz; i++)
        {
            auto x = q.front();
            q.pop();

            // 若到达终点，提前退出
            if (x.first == x2 && x.second == y2) {
                cout << cnt[x2][y2] << endl;
                return 0;
            }

            // 探索四个方向
            for(int k = 0; k < 4; k++)
            {
                int a = x.first + idx[k];
                int b = x.second + idy[k];

                // 检查边界、是否访问过、是否可通行（.表示可走）
                if(a >= 1 && a <= n && b >= 1 && b <= m && !vis[a][b] && nums[a][b] == '.')
                {
                    q.push({a, b});
                    cnt[a][b] = cnt[x.first][x.second] + 1;  // 步数+1
                    vis[a][b] = true;
                }
            }
        }
    }
    
    // 若终点不可达
    cout << -1 << endl;
    return 0;
}

```

## **主持人调度（二）**

```C++
class Solution 
{
public:
    int minmumNumberOfHost(int n, vector<vector<int> >& startEnd) 
    {
        sort(startEnd.begin(), startEnd.end());
        priority_queue<int, vector<int>, greater<int>> heap; // 创建一个小堆
        heap.push(startEnd[0][1]); // 先把第一个区间放进去

        for(int i = 1; i < n; i++) // 处理剩下的区间
        {
            int a = startEnd[i][0], b = startEnd[i][1];
            if(a >= heap.top()) // 没有重叠
            {
                heap.pop();
                heap.push(b);
            }
            else heap.push(b);
        }
        return heap.size();
    }
};
```

