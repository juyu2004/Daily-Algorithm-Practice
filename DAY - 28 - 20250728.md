# DAY - 28 - 20250728

两道简单二叉树:

## 二叉树的最近公共祖先 —— C++

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) 
    {
        if(root == nullptr || root == p || root == q) return root;

        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        if(left && right) return root;

        return left ? left : right;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3731322/er-cha-shu-de-zui-jin-gong-gong-zu-xian-36sh6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

算法核心思想：

这是一个经典的递归算法，基于以下几个关键点：

递归终止条件：

当当前节点为空时，返回nullptr

当当前节点等于p或q时，返回当前节点（因为自己可以是自己的祖先）

分治策略：

递归在左子树中查找 LCA

递归在右子树中查找 LCA

结果合并：

如果左右子树都找到非空结果，说明p和q分别位于当前节点的两侧，当前节点即为 LCA

如果只有左子树找到结果，说明p和q都在左子树中

如果只有右子树找到结果，说明p和q都在右子树中

## 二叉树的中序遍历 —— C++

中序遍历核心思想

中序遍历是二叉树遍历的一种，顺序为：

递归遍历左子树

访问当前节点

递归遍历右子树

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution 
{
    vector<int> ret;
public:
    vector<int> inorderTraversal(TreeNode* root) 
    {
        if(root == nullptr) return ret;
        inorderTraversal(root->left);
        ret.push_back(root->val);
        inorderTraversal(root->right);
        return ret;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/solutions/3731330/er-cha-shu-de-zhong-xu-bian-li-c-by-wu-g-6j8y/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

```C++
#include <iostream>
#include <string>
using namespace std;
 
int main()
{
    string str1, str2;
    cin >> str1 >> str2;  // 输入：str1（短串）、str2（长串）
 
    int n = str1.size(), m = str2.size();  // n: 短串长度，m: 长串长度
    // ret 初始化为 m（极端情况：所有字符都不匹配，最多不相等数是 m，但实际会更小）
    int ret = m; 
 
    // 滑动窗口：枚举 str2 中所有长度为 n 的子串的起始位置 i
    for(int i = 0; i <= m - n; i++) 
    {
        int tmp = 0;  // 记录当前子串与 str1 的不相等字符数
        // 对比 str1 和 str2 的子串 [i, i+n)
        for(int j = 0; j < n; j++) 
        {
            if(str1[j] != str2[i + j])  // 字符不相等时，tmp++
                tmp++;
        }
        // 更新最小不相等数：ret 始终保存当前最优解
        ret = min(ret, tmp); 
    }
 
    cout << ret << endl;  // 输出最小不相等数
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/781578879206010880
来源：牛客网
```

## 添加字符

题目链接：https://www.nowcoder.com/questionTerminal/b2b816e20e8343b49abbaf493886ce26

```C++
#include <iostream>
#include <string>
using namespace std;
 
int main()
{
    string str1, str2;
    cin >> str1 >> str2;  // 输入：str1（短串）、str2（长串）
 
    int n = str1.size(), m = str2.size();  // n: 短串长度，m: 长串长度
    // ret 初始化为 m（极端情况：所有字符都不匹配，最多不相等数是 m，但实际会更小）
    int ret = m; 
 
    // 滑动窗口：枚举 str2 中所有长度为 n 的子串的起始位置 i
    for(int i = 0; i <= m - n; i++) 
    {
        int tmp = 0;  // 记录当前子串与 str1 的不相等字符数
        // 对比 str1 和 str2 的子串 [i, i+n)
        for(int j = 0; j < n; j++) 
        {
            if(str1[j] != str2[i + j])  // 字符不相等时，tmp++
                tmp++;
        }
        // 更新最小不相等数：ret 始终保存当前最优解
        ret = min(ret, tmp); 
    }
 
    cout << ret << endl;  // 输出最小不相等数
    return 0;
}


作者：程家斌
链接：https://www.nowcoder.com/discuss/781578879206010880?sourceSSR=users
来源：牛客网
```

## 数组变换

题目链接 ：https://www.nowcoder.com/questionTerminal/c55f4f15cc3f4ff0adede7f9c69fa0c1

```C++
#include <iostream>
using namespace std;
 
// 定义数组最大长度，题目中说数组大小满足 1 ≤ n ≤ 50，这里设为 51 足够存储
const int N = 51;
// 用于存储输入的数组
int a[N];
// 记录数组中的最大值，后续作为统一目标值
int b = 0;
// 记录数组的实际长度
int n;
 
// 功能：判断能否通过「将数组元素不断乘 2」的操作，让所有元素最终等于 b
bool fun()
{
    // 遍历数组中的每一个元素
    for(int i = 0; i < n; i++)
    {
        // 第一步：检查 b 是否能被当前数组元素 a[i] 整除
        // 如果不能整除，说明 a[i] 无法通过「乘 2」操作得到 b，直接返回 false
        if(b % a[i]) return false;
 
        // 第二步：计算 b 是 a[i] 的多少倍（商）
        int x = b / a[i];
 
        // 关键判断：x 是否是 2 的幂
        // x & -x 是位运算技巧，用于提取 x 二进制中最低位的 1 对应的值
        // 例如 x=8（二进制 1000），x & -x = 8；x=6（二进制 0110），x & -x = 2
        // 若 x 是 2 的幂，x - (x & -x) 结果为 0；否则结果非 0
        if(x - (x & -x)) return false;
    }
    // 所有元素都满足条件，返回 true
    return true;
}
 
int main()
{
    // 输入数组长度 n
    cin >> n;
    for(int i = 0; i < n; i++)
    {
        // 输入数组的每个元素
        cin >> a[i];
        // 更新 b 为当前最大值（初始 b=0，后续不断比较取最大）
        b = max(b, a[i]);
    }
 
    // 调用 fun 函数判断是否能统一，根据结果输出 YES 或 NO
    if(fun()) cout << "YES" << endl;
    else cout << "NO" << endl;
 
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/782961552537239552?sourceSSR=users
来源：牛客网
```

**变量与目标代码目标：**判断数组所有元素能否通过不断乘 2操作，最终变得全部相等。核心思路：假设最终统一到数组的最大值 b（因为乘 2 只能让数变大 / 不变，若最大值都无法作为统一目标，更小的数更不可能），验证其他元素能否通过乘 2 得到 b。

**fun 函数的关键逻辑整除检查：**if(b % a[i])若 b 不能被 a[i] 整除，说明 a[i] 无法通过「乘 2」得到 b（因为 b 必须是 a[i] 乘 2 若干次的结果），直接返回 false。2 的幂判断：x - (x & -x)x = b / a[i] 表示 a[i] 要乘多少次 2 才能得到 b（例如 a[i]=2，b=8，则 x=4，即需要乘 2 次：2×2×2=8 ）。若 x 是 2 的幂（如 1,2,4,8... ），说明 a[i] 可以通过「乘 2」操作得到 b；否则无法通过，返回 false。

## 装箱问题

题目链接：https://ac.nowcoder.com/acm/problem/16693

这本质是 **0-1 背包问题**的变形：

- **“0-1”**：每个物品**选或不选**（不能分割，要么装，要么不装）。
- **背包容量**：箱子容量 `V`。
- **价值最大化**：这里的 “价值” 等价于**物品总体积**，我们要让总体积尽可能大（但不超过 `V`），这样剩余空间 `V - 总体积` 才会最小。
- **`dp`** **数组定义**：`dp[j]` 表示**当箱子容量为** **`j`** **时，能装下物品的最大总体积**。初始值 `dp[j] = 0`，表示 “初始状态下（没选任何物品），最大体积是 0”。

```C++
#include <iostream>
#include <vector>
using namespace std;
 
int main()
{
    int V, n;
    cin >> V >> n;
     
    vector<int> dp(V + 1, 0);
    vector<int> nums(n);
    for(int i = 0; i < n; i++)
        cin >> nums[i];
         
    for(int i = 0; i < n; i++)
    {
        for(int j = V; j >= nums[i]; j--)
        {
            dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
        }
    }
     
    cout << V - dp[V] << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/782965142928572416?sourceSSR=users
来源：牛客网
```

作者：程家斌
链接：https://www.nowcoder.com/discuss/782965142928572416?sourceSSR=users
来源：牛客网
