# DAY - 27 - 20250727

先来两道力扣热题100

## 删除链表的倒数第 N 个结点

这里采用的还是双指针，让一个快指针先跑 N 次，然后快慢指针一起跑，这样快慢指针相差就是 N，满指针就是倒数第 N 个结点。

但是，这里有一些问题：1. 正常来说，我们循环结束条件就是 fast != nullptr，这里就会有问题，此时 slow 指向的结点就是我们需要删除的结点，但是删除这个结点怎么维护左右两边的指针的指向呢？2. 我们返回什么结点呢？头节点？它可能会被删除啊！

所以这里我采用了虚拟头节点 dummy 连接 head，快慢指针全部初始化指向 dummy, 这样我们首先不怕删除头结点的情况，我们只需要返回 dummy->next 即可，至于怎么维护删除结点两边的指向，我们可以把循环的条件变为 ：fast && fast->next ，也就是说，到删除结点的前一个位置就停下来，然后就可以执行 cur->next = cur->next->next; 跳过该结点

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) 
    {
        if(head->next == nullptr) return nullptr;

        ListNode* dummy = new ListNode(0, head);
        ListNode* tmp = dummy, *cur = dummy;
        while(n--) tmp = tmp->next;

        while(tmp && tmp->next != nullptr)
        {
            tmp = tmp->next;
            cur = cur->next;
        }    
        
        cur->next = cur->next->next;
        return dummy->next;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solutions/3730454/shan-chu-lian-biao-de-dao-shu-di-n-ge-ji-55aj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## K个一组翻转链表

```C++
class Solution 
{
public:
    ListNode* reverseKGroup(ListNode* head, int k) 
    {
        // 创建虚拟头节点，简化边界处理
        ListNode* dummy = new ListNode(0, head);
        ListNode* cur = dummy; // 当前处理组的前驱节点
        
        while(true)
        {
            ListNode* node1 = cur->next; // 当前组的第一个节点
            ListNode* node2 = HaveKNode(node1, k); // 尝试找到当前组的第k个节点
            
            // 如果不足k个节点，退出循环
            if(node2 == nullptr) break;

            ListNode* next = node2->next; // 下一组的头节点
            
            // 反转当前组的k个节点（从node1到node2）
            Reverse_List(node1, node2);
            
            // 连接反转后的链表段
            // cur->next应指向反转后的头节点（即原node2）
            cur->next = node2;
            
            // 反转后的尾节点（原node1）应连接到下一组的头节点
            node1->next = next;
            
            // 更新cur为下一组的前驱节点（即当前反转后的尾节点node1）
            cur = node1;
        }
        
        ListNode* result = dummy->next;
        delete dummy;
        return result;
    }

    // 查找从start开始的第k个节点
    // 如果不足k个节点，返回nullptr
    ListNode* HaveKNode(ListNode* start, int k)
    {
        while(start && k > 1) // 注意这里k>1，循环k-1次
        {
            start = start->next;
            k--;
        }
        return start;
    }

    // 反转从start到end的所有节点（包含end）
    void Reverse_List(ListNode* start, ListNode* end)
    {
        ListNode* prev = nullptr, *cur = start;

        while(prev != end)
        {
            ListNode* tmp = cur->next;
            cur->next = prev;
            prev = cur;
            cur = tmp;
        }
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/solutions/3731309/kge-yi-zu-fan-zhuan-lian-biao-c-by-wu-gu-ce1d/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

主函数流程：

使用虚拟头节点dummy简化边界处理ran每次循环尝试找到当前组的第 k 个节点node2

调用Reverse_List反转当前组

连接反转后的链表段，更新指针位置

HaveKNode 函数：

从start开始移动 k-1 步，找到第 k 个节点

如果不足 k 个节点，返回nullptr

Reverse_List 函数：

尝试反转从start到end的所有节点

##   爱丽丝的人偶（一）

```C++
#include <iostream>
 
using namespace std;
 
int main()
{
    int n;
    cin >> n;
    int left = 1, right = n;
    while(left < right)
    {
        cout << left << " " << right << " ";
        left++;
        right--;
    }
     
    if(left == right) cout << left;
         
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/780112986420625408?sourceSSR=users
来源：牛客网
```

我这边采用直接构造，一大一小~~

## 集合

```C++

#include <iostream>
#include <set>
using namespace std;
 
int main()
{
    set<int> ret;
    int n, m;
    cin >> n >> m;
 
    for(int i = 0; i < n; i++)
    {
        int x;
        cin >> x;
        ret.insert(x);
    }
 
    for(int i = 0; i < m; i++)
    {
        int x;
        cin >> x;
        ret.insert(x);
    }
 
    for(auto x : ret) cout << x << " ";
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/780131320256114688?sourceSSR=users
来源：牛客网
```

## 最长回文子序列

```C++
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>  // 用于max函数
using namespace std;
 
int main()
{
    string str;
    cin >> str;  // 读取输入字符串
 
    int n = str.size();  // 获取字符串长度
    vector<vector<int>> dp(n, vector<int>(n, 0));  // 创建二维数组dp，dp[i][j]表示str[i..j]的最长回文子序列长度
     
    // 初始化：单个字符的最长回文子序列长度为1
    for(int i = 0; i < n; i++)
        dp[i][i] = 1;
 
    // 按子串长度从小到大遍历，从长度2开始，直到整个字符串
    for(int len = 2; len <= n; len++)
    {
        // 遍历所有可能的起始索引i
        for(int i = 0; i + len <= n; i++)
        {
            int j = i + len - 1;  // 计算对应的结束索引
             
            // 如果当前子串的首尾字符相同
            if(str[i] == str[j])
                dp[i][j] = dp[i + 1][j - 1] + 2;  // 长度为中间部分的长度加2
             
            // 如果首尾字符不同
            else
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);  // 取舍弃首字符或尾字符后的最大值
        }
    }
     
    // 输出整个字符串的最长回文子序列长度
    cout << dp[0][n - 1] << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/780407878342500352?sourceSSR=users
来源：牛客网
```

