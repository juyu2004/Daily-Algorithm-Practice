# DAY35 - 20250805

## 接雨水

```C++
// 暴力方法
// 一、问题本质拆解
// 雨水能留存的条件：当前柱子左右两侧存在更高的柱子，形成 “凹槽”。
// 单个柱子能接的雨水量 = min(左侧最高柱高度, 右侧最高柱高度) - 当前柱高度（若结果 > 0 则有效，否则接不到水）。
// 总雨水量 = 所有柱子可接雨水量的总和。
// 时间复杂度为 O(n ^ 2)
class Solution 
{
public:
    int trap(vector<int>& height) 
    {
        int n = height.size();
        int ret = 0;
        for(int i = 0; i < n; i++)
        {
            int maxleft = 0;
            for(int j = i; j >=0; j--) maxleft = max(maxleft, height[j]);
            int maxright = 0;
            for(int j = i; j < n; j++) maxright = max(maxright, height[j]);
            ret += min(maxleft, maxright) - height[i];
        }
        return ret;
    }
};

// 动态规划（优化暴力法的重复计算）
// 暴力法中，每个柱子的左右最高柱会被重复计算（比如计算 i 的左侧最高时，i-1 的左侧最高已算过）。
// 优化：用两个数组 leftMax、rightMax 预处理每个柱子的左侧最高和右侧最高，避免重复遍历。

class Solution 
{
public:
    int trap(vector<int>& height) 
    {
        int n = height.size();
        int ret = 0;
        
        vector<int> leftmax(n);
        leftmax[0] = height[0];
        for(int i = 1; i < n; i++) leftmax[i] = max(leftmax[i - 1], height[i]);

        vector<int> rightmax(n);
        rightmax[n - 1] = height[n - 1];
        for(int i = n - 2; i >= 0; i--) rightmax[i] = max(rightmax[i + 1], height[i]);

        for(int i = 0; i < n; i++)
            ret += min(leftmax[i], rightmax[i]) - height[i];

        return ret;
    }
};

// 双指针（进一步优化空间）
// 动态规划需要额外 \(O(n)\) 空间存 leftMax 和 rightMax。
// 若 height[left] < height[right]，则 left 的左侧最高由 leftMax[left] 决定（因为 right 侧有更高的柱能 “兜底”）。
// 反之，right 的右侧最高由 rightMax[right] 决定。

class Solution 
{
public:
    int trap(vector<int>& height) 
    {
        int n = height.size();
        int ret = 0;
        
        int left = 0, right = n - 1;
        int leftmax = 0, rightmax = 0;
        while(left < right)
        {
            leftmax = max(leftmax, height[left]);
            rightmax = max(rightmax, height[right]);

            if(leftmax < rightmax)
                ret += leftmax - height[left++];
            else
                ret += rightmax - height[right--];
        }
        return ret;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/trapping-rain-water/solutions/3738566/jie-yu-shui-c-by-wu-guan-feng-yue-ca-ce0j/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 搜索二维矩阵 II 

此解法利用了矩阵 每行内部元素是递增有序 的特点。对于每一行，使用 lower_bound 函数（该函数基于二分查找实现，在有序区间中找到第一个大于等于目标值的元素的位置 ）来快速查找目标值：

遍历矩阵的每一行，对当前行 x ，调用 lower_bound 找到第一个大于等于 target 的元素的迭代器 it 。 然后判断 it 是否在该行的有效范围内（it != x.end() ），并且解引用 it 后的值是否等于 target ，如果满足，说明在当前行找到目标值，返回 true 。 若遍历完所有行都没找到符合条件的情况，返回 false 。 该方法的时间复杂度取决于每行的二分查找操作，假设矩阵有 n 行，每行有 m 个元素，那么时间复杂度是 O(n * log m) ，空间复杂度是 O(1) （忽略 lower_bound 内部可能使用的栈空间等，主要额外空间是常数级 ）。相比于暴力逐行遍历查找（时间复杂度 O(n * m) ），在每行元素较多时，二分查找的方式能有效降低时间消耗，不过和第一种双指针方法比，在矩阵行列都有序的场景下，双指针方法通常更高效一些，但此方法的优点是实现简单，且适用于仅保证每行有序的矩阵场景。

```C++
class Solution 
{
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) 
    {
        if(matrix.empty() || matrix[0].empty()) return false;

        int n = matrix.size(), m = matrix[0].size();
        int row = 0, column = m - 1;

        while(row < n && column >= 0)
        {
            if(matrix[row][column] == target) return true;
            else if(matrix[row][column] > target) column--;
            else row++;
        }
        return false;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/3739516/sou-suo-er-wei-ju-zhen-ii-c-by-wu-guan-f-n2gb/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 排序子序列

```C++
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int arr[N];
int ret;

int main()
{
    int n;
    cin >> n;
    for(int i = 0; i < n; i++) cin >> arr[i];

    int i = 0;
    while(i < n)
    {
        if(i == n - 1)
        {
            ret++;
            break;
        }
        
        if(arr[i] < arr[i + 1])
        {
            while(i < n - 1 && arr[i] <= arr[i + 1]) i++;
            ret++;
        }
        else if(arr[i] > arr[i + 1])
        {
            while(i < n - 1 && arr[i] >= arr[i + 1]) i++;
            ret++;
        }
        
        i++;
    }
    cout << ret << endl;
    return 0;
}
```

## 消减整数

```C++
#include <iostream>
using namespace std;

int t, h;

int fun()
{
    int ret = 0, a = 1;
    while(h)
    {
        h -= a;
        ret++;
        if(h % (a * 2) == 0)
            a *= 2;
    }
    return ret;
}

int main()
{
    cin >> t;
    while(t--)
    {
        cin >> h;
        cout << fun() << endl;
    }
    return 0;
}
```

##  **最长上升子序列(二)**

```C++
class Solution 
{
public:
    int LIS(vector<int>& a) 
    {
        int ret = 0;
        int n = a.size();
        vector<int> dp(n, 1);

        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < i; j++)
                if(a[j] < a[i])
                    dp[i] = max(dp[j] + 1, dp[i]);

            ret = max(dp[i], ret);
        }

        return ret;
    }
};
```

动态规划的思路需要进行优化，采用贪心 + 二分！

```C++
class Solution 
{
    int dp[100010] = {0}; // dp[i] 表示：长度为 i 的最小末尾
    int pos = 0;
public:
    int LIS(vector<int>& a) 
    {
        for(auto x : a)
        {
            // 查找 x 应该放在哪个位置
            if(pos == 0 || x > dp[pos])
                dp[++pos] = x;
            else
            {
                // 二分查找插入位置
                int l = 1, r = pos;
                while(l < r)
                {
                    int mid = (l + r) / 2;
                    if(dp[mid] >= x) r = mid;
                    else l = mid + 1;
                }
                dp[l] = x;
            }
        }
        return pos;
    }
};
```

我们在考虑最⻓递增⼦序列的⻓度的时候，其实并不关⼼这个序列⻓什么样⼦，我们只是关⼼最后
⼀个元素是谁。这样新来⼀个元素之后，我们就可以判断是否可以拼接到它的后⾯。
因此，我们可以创建⼀个数组，统计⻓度为 x 的递增⼦序列中，最后⼀个元素是谁。为了尽可能
的让这个序列更⻓，我们仅需统计⻓度为 x 的所有递增序列中最后⼀个元素的「最⼩值」。
统计的过程中发现，数组中的数呈现「递增」趋势，因此可以使⽤「⼆分」来查找插⼊位置。  