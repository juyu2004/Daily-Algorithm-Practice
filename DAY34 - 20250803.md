# DAY34 - 20250803

## 盛水最多的容器

题目分析：盛最多水的容器 这道题的核心是求解一个容器能容纳的最大水量。想象有一个容器由数组中两个不同位置的 "木板" 组成，木板的高度由数组元素值表示，两木板之间的距离是宽度，容器的盛水量由短板高度 × 宽度决定。我们需要找到能使盛水量最大的两个木板位置。 解题思路：双指针法 这道题最直观的暴力解法是检查所有可能的木板组合，时间复杂度为 O (n²)。而双指针法则通过一次遍历就能找到最优解，时间复杂度优化到 O (n)，核心思路基于：

盛水量由短板高度和两板间距共同决定 移动短板可能找到更高的板，从而增加盛水量；**移动长板只会减小间距，盛水量一定不会增加！**

```C++
class Solution 
{
public:
    int maxArea(vector<int>& height) 
    {
        // 获取数组长度（木板数量）
        int n = height.size();
        // 初始化双指针：左指针指向最左侧木板，右指针指向最右侧木板
        int left = 0, right = height.size() - 1;
        // 用于记录最大盛水量，初始化为0
        int max_capacity = 0;

        // 当左右指针未相遇时，继续寻找更大的盛水量
        while(left < right)
        {
            // 容器的高度由较短的木板决定（短板效应）
            int length = min(height[left], height[right]);
            // 容器的宽度是两木板之间的距离
            int width = right - left;
            // 计算当前容器的盛水量，并更新最大盛水量
            max_capacity = max(max_capacity, length * width);

            // 移动策略：总是移动较短的木板
            // 因为移动长木板只会减小宽度，而高度仍受限于短板，盛水量必然减少
            if(height[left] < height[right]) 
                left++;  // 左板较短，右移左指针寻找更高的板
            else 
                right--; // 右板较短，左移右指针寻找更高的板
        }
        
        // 返回最大盛水量
        return max_capacity;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/container-with-most-water/solutions/3738455/sheng-zui-duo-shui-de-rong-qi-c-by-wu-gu-5jku/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 三数之和

核心思路

排序预处理：先对数组排序，为双指针操作和去重提供基础

固定一个元素 + 双指针找另外两个元素：将三数之和转化为两数之和问题

全程去重：在遍历过程中主动跳过重复元素，避免生成重复三元组

```C++
class Solution 
{
public:
    vector<vector<int>> threeSum(vector<int>& nums) 
    {
        int n = nums.size();
        // 1. 排序：为双指针和去重做准备
        sort(nums.begin(), nums.end());
        vector<vector<int>> ret;  // 存储结果

        // 2. 外层循环：固定三元组中的第一个元素 nums[i]
        // 注意循环终止条件是 i < n - 2，确保至少有两个元素在i之后
        for(int i = 0; i < n - 2; i++)
        {
            // 去重1：跳过第一个元素的重复值
            // 当i>0且当前元素与前一个相同时，直接跳过（避免重复三元组）
            if(i > 0 && nums[i] == nums[i - 1]) 
                continue;

            // 3. 双指针初始化：left指向i的下一个元素，right指向数组末尾
            int left = i + 1, right = n - 1;
            
            // 4. 双指针寻找另外两个元素，使三数之和为0
            while(left < right)
            {
                // 计算当前三数之和
                int sum = nums[i] + nums[left] + nums[right];
                
                if(sum == 0)
                {
                    // 找到符合条件的三元组，加入结果集
                    ret.push_back({nums[i], nums[left], nums[right]});
                    
                    // 去重2：跳过left指针的重复值
                    // 当left < right且当前元素与下一个相同时，右移left
                    while(left < right && nums[left] == nums[left + 1]) 
                        left++;
                    
                    // 去重3：跳过right指针的重复值
                    // 当left < right且当前元素与前一个相同时，左移right
                    while(left < right && nums[right] == nums[right - 1]) 
                        right--;
                    
                    // 找到有效组合后，同时移动双指针继续寻找下一组
                    left++;
                    right--;
                }
                // 若总和大于0，说明需要减小总和，右指针左移
                else if(sum > 0)
                    right--;
                // 若总和小于0，说明需要增大总和，左指针右移
                else 
                    left++;
            }
        }
        return ret;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/3sum/solutions/3738479/san-shu-zhi-he-c-by-wu-guan-feng-yue-ca-36vd/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 游游的重组偶数

```C++
#include <iostream>
using namespace std;
 
int main()
{
    int n;
    cin >> n;
    while(n--)
    {
        string str;
        cin >> str;
 
        int n = str.size();
        for(int i = n - 1; i >= 0; i--)
        {
            if(str[i] % 2 == 0)
            {
                swap(str[i], str[n - 1]);
                break;
            }
        }
        if(str[n - 1] % 2 == 0) cout << str << endl;
        else cout << -1 << endl;
    }
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/788036800655724544
来源：牛客网
```

## 体操队形

```C++
#include <iostream>
using namespace std;
 
const int N = 20;
int nums[N], ret = 0, n;
bool vis[N] = {false};
 
void dfs(int pos)
{
    if(pos == n + 1)
    {
        ret++;
        return;
    }
     
    for(int i = 1; i <= n; i++)
    {
        if(vis[i]) continue; // 当前 i 已经放过了 - 剪枝
        if(vis[nums[i]]) return; // 剪枝
        vis[i] = true; // 相当于放上 i 号队员
        dfs(pos + 1);
        vis[i] = false; // 回溯 - 还原现场
    }
}
 
int main()
{
    cin >> n;
     
    for(int i = 1; i <= n; i++)
        cin >> nums[i];
     
    dfs(1);
     
    cout << ret << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/788053023728599040
来源：牛客网
```

## 二叉树中的最大路径和

```C++

class Solution 
{
private:
    int ret;
public:
    int maxPathSum(TreeNode* root)
    {
        ret = INT_MIN;
        dfs(root);  
        return ret;
    }

    int dfs(TreeNode* root)
    {
        if(root == nullptr) return 0;

        int left = max(dfs(root->left), 0);

        int right = max(dfs(root->right), 0);

        ret = max(ret, root->val + left + right);
       
        return root->val + max(left, right);
    }
};
```

