# DAY - 26 - 20250726

​	老规矩, 先来两道题练练手!

## 合并两个有序链表 —— C++

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution 
{
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) 
    {
        if(list1 == nullptr) return list2;
        if(list2 == nullptr) return list1;

        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;

        while(list1 && list2)
        {
            if(list1->val < list2->val)
            {
                cur->next = list1;
                list1 = list1->next;
            }
            else 
            {
                cur->next = list2;
                list2 = list2->next;
            }
            cur = cur->next;
        }
        if(list1) cur->next = list1;
        if(list2) cur->next = list2;

        cur = dummy->next;
        delete dummy;
        return cur;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/merge-two-sorted-lists/solutions/3729660/he-bing-liang-ge-you-xu-lian-biao-c-by-w-i96z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

使用递归进行解答：

终止条件：

当 list1 或 list2 为空时，直接返回另一个链表（因为有序链表剩余部分可直接拼接）。

递归选择节点：

若 list1->val < list2->val，则 list1 作为当前节点，其 next 指向 mergeTwoLists(list1->next, list2)（递归合并剩余节点）。

反之，list2 作为当前节点，其 next 指向 mergeTwoLists(list1, list2->next)。

返回值：每次递归返回当前选择的节点（构建新链表的 “当前头节点”）。

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution 
{
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) 
    {
        if(list1 == nullptr) return list2;
        if(list2 == nullptr) return list1;

        if(list1->val < list2->val) 
        {
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        }
        else
        {
            list2->next = mergeTwoLists(list1, list2->next);
            return list2;
        }
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/merge-two-sorted-lists/solutions/3729660/he-bing-liang-ge-you-xu-lian-biao-c-by-w-i96z/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 两数相加 —— C++

这个不是完全模拟我们平时加法的过程，它并没有对齐！！！

所以一开始我写的代码是错误的！！！

```C++
// 这不是严格意思上的对齐，所以这个解法是有问题的！！！
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution 
{
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) 
    {
        l1 = Reverse_List(l1);
        l2 = Reverse_List(l2);

        int flag = 0;
        ListNode* dummy = new ListNode(0);
        while(l1 && l2)
        {
            int val = (l1->val + l2->val + flag) % 10;
            flag = (l1->val + l2->val + flag) / 10;
            ListNode* node = new ListNode(val);
            node->next = dummy->next;
            dummy->next = node;

            l1 = l1->next;
            l2 = l2->next;
        }

        while(l1) 
        {
            int val = (l1->val + flag) % 10;
            flag = (l1->val + flag) / 10;
            ListNode* node = new ListNode(val);
            node->next = dummy->next;
            dummy->next = node;

            l1 = l1->next;
        }

        while(l2) 
        {
            int val = (l2->val + flag) % 10;
            flag = (l2->val + flag) / 10;
            ListNode* node = new ListNode(val);
            node->next = dummy->next;
            dummy->next = node;

            l2 = l2->next;
        }

        if(flag) 
        {
            int val = flag;

            ListNode* node = new ListNode(val);
            node->next = dummy->next;
            dummy->next = node;
        }

        ListNode* cur = dummy->next;
        delete dummy;
        return Reverse_List(cur);
    }

    ListNode* Reverse_List(ListNode* head)
    {
        ListNode* newhead = new ListNode(0);

        while(head)
        {
            ListNode* tmp = head->next;
            head->next = newhead->next;
            newhead->next = head;
            head = tmp;
        }

        ListNode* cur = newhead->next;
        delete newhead;
        return cur;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/add-two-numbers/solutions/3730375/liang-shu-xiang-jia-c-by-wu-guan-feng-yu-gmmc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

正确代码:

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution 
{
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) 
    {
        ListNode* head = new ListNode(0);
        ListNode* cur = head;
        int cnt = 0;
        while(l1 || l2 || cnt)
        {
            if(l1) 
            {
                cnt += l1->val;
                l1 = l1->next;
            }
            if(l2)
            {
                cnt += l2->val;
                l2 = l2->next;
            }
            cur->next = new ListNode(cnt % 10);
            cur = cur->next;
            cnt /= 10;
        }
        cur = head->next;
        delete head;
        return cur;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/add-two-numbers/solutions/3730375/liang-shu-xiang-jia-c-by-wu-guan-feng-yu-gmmc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

然后就是三道牛客笔试强训:
## 经此一役小红所向无敌 —— C++

题目连接：[https://ac.nowcoder.com/acm/problem/223985](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fac.nowcoder.com%2Facm%2Fproblem%2F223985)

第一题还是老样子,必须简单!
直接模拟就好！

```C++
#include <iostream>
 
using namespace std;
 
int main()
{
    long long a, b, h, k;
    cin >> a >> h >> b >> k;
     
    long long ret = 0;
    while(h > 0 && k > 0)
    {
        ret += a;
        ret += b;
         
        h -= b;
        k -= a;
    }
     
    if(h > 0) ret += a * 10;
    if(k > 0) ret += b * 10;
     
    cout << ret << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/779366688335675392?sourceSSR=users
来源：牛客网
```

## 连续子数组最大和(ACM版本)

```C++
#include <iostream>
#include <vector>
#include <climits>  // 提供INT_MIN，表示负无穷大
using namespace std;
 
const int N = 2e5 + 10;  // 数组最大长度
int arr[N];  // 存储输入的数组
int n;  // 数组实际长度
 
int main()
{
    cin >> n;  // 读取数组长度
    for(int i = 0; i < n; i++)
        cin >> arr[i];  // 读取数组元素
     
    vector<int> dp(n);  // dp[i]表示以arr[i]结尾的连续子数组的最大和
    int max_num = INT_MIN;  // 全局最大和，初始化为负无穷大
     
    // 处理边界：第一个元素的最大子数组和就是它本身
    dp[0] = arr[0];
    max_num = max(max_num, dp[0]);  // 更新全局最大值
     
    // 从第二个元素开始遍历，计算每个位置的dp[i]
    for(int i = 1; i < n; i++)
    {
        // 状态转移：两种选择取较大值
        dp[i] = max(dp[i - 1] + arr[i], arr[i]);
        // 更新全局最大和
        max_num = max(max_num, dp[i]);
    }       
     
    // 输出全局最大和。这里的判断是冗余的，因为max_num至少会被初始化为dp[0]
    cout << (max_num == INT_MIN ? dp[0] : max_num) << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/779685703197188096?sourceSSR=users
来源：牛客网
```

初始化 max_num = INT_MIN：确保任何元素的值都能更新max_num，即使数组全为负数。

边界处理：dp[0] = arr[0]，因为以第一个元素结尾的子数组只有它本身。

状态转移的逻辑：若dp[i-1] > 0，则dp[i] = dp[i-1] + arr[i]（加入前面的子数组）。若dp[i-1] ≤ 0，则dp[i] = arr[i]（以自己为起点）。

然后可以是空间优化，不需要额外的 dp 数组，利用两个变量进行优化！

```C++
#include <iostream>
#include <vector>
using namespace std;
 
const int N = 2e5 + 10;  // 数组最大长度（预处理优化）
int arr[N];  // 存储输入的数组
int n;  // 数组实际长度
 
int main()
{
    cin >> n;  // 读取数组长度
    for(int i = 0; i < n; i++)
        cin >> arr[i];  // 读取数组元素
     
    // a: 以当前元素结尾的连续子数组的最大和
    // b: 全局最大和
    int a = arr[0], b = arr[0];
     
    // 从第二个元素开始遍历，计算每个位置的最大子数组和
    for(int i = 1; i < n; i++)
    {
        // 状态转移：更新"以当前元素结尾的最大和"
        a = max(arr[i], a + arr[i]);
        // 更新全局最大和
        b = max(a, b);
    }       
     
    cout << b << endl;  // 输出全局最大和
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/779685703197188096?sourceSSR=users
来源：牛客网
```

变量初始化：a = arr[0]：处理边界情况，以第一个元素结尾的子数组只有它本身。b = arr[0]：初始全局最大值为第一个元素，确保即使数组全为负数也能正确返回最大值。

状态转移的逻辑：若 a > 0，则 a = a + arr[i]（加入前面的子数组）。若 a ≤ 0，则 a = arr[i]（以自己为起点）。

## 非对称之美

这个题目如果从如果在字符串中找到最长非回文子串会非常困难，但是如果转变一下思路，就会很简单！

大家一开始很容易想到，从两边或者从中间扩散或者靠近去找，但是这种情况比较复杂。不好判断，但是我们可以这么想，这个字符串可以分为两类：是回文字符串，不是回文字符串，如果不是回文字符串，我们直接返回整个字符串的长度即可。如果是回文串，我们返回这个字符串 - 1的长度即可。但是这样会遇到一种特殊的情况，比如：aaaaa，这是一个回文串，但是它最长非回文串为0，这种情况就需要单独判断。

```C++
#include <iostream>
#include <string>
 
using namespace std;
 
int main()
{
    string str;
    cin >> str;
     
    int left = 0, right = str.size() - 1, flag = 1;
    while(left < right)
    {
        if(str[left] != str[right])
        {
            flag = 0;
            break;
        }
        right--;
        left++;
    }
    // 这里还需要注意一个问题，如果是回文，我们还需要考虑这种情况
    // aaaaa : 字符全是相同的情况，这时候我们不是回文的字符串长度为0
    if(flag)
    {
        int cnt = 1;
        for(int i = 1; i < str.size(); i++)
        {
            if(str[i] != str[0])
            {
                cout << str.size() - 1 << endl;
                cnt = 0;
                break;
            }
        }
        if(cnt) cout << 0 << endl;
    }
    else cout << str.size() << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/779769679077269504?sourceSSR=users
来源：牛客网
```

