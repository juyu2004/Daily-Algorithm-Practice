# DAY - 32 - 20250801

## 水位上升的泳池中游泳 

```C++
#include <vector>
#include <queue>
#include <climits>
using namespace std;

class Solution 
{
    // 定义四个方向数组，分别对应右、左、下、上四个方向的坐标偏移
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};
public:
    int swimInWater(vector<vector<int>>& grid) 
    {
        // 获取泳池网格的边长 n
        int n = grid.size();
        // 优先队列，存储的元素是 vector<int>，包含三个值：[当前路径最大高度, 横坐标 x, 纵坐标 y]
        // 队列按照 vector<int> 的字典序升序排列（小顶堆），确保每次取出当前路径最大高度最小的节点
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        // visit 二维数组，记录到达每个坐标 (x, y) 时的最小路径最大高度，初始化为 INT_MAX（表示未访问或初始状态）
        vector<vector<int>> visit(n, vector<int>(n, INT_MAX));

        // 将起点 (0, 0) 加入优先队列，初始时路径最大高度就是起点网格的高度
        pq.push({grid[0][0], 0, 0});
        // 标记起点的最小路径最大高度为 grid[0][0]
        visit[0][0] = grid[0][0];

        // 优先队列循环处理，直到队列为空
        while(!pq.empty())
        {
            // 取出队列顶部元素（当前路径最大高度最小的节点数据）
            auto data = pq.top();
            pq.pop();

            // 解析出当前路径的最大高度、当前节点的横纵坐标
            int max_height = data[0];
            int x = data[1];
            int y = data[2];

            // 如果当前节点是右下角 (n - 1, n - 1)，说明到达终点，返回此时的路径最大高度
            if(x == n - 1 && y == n - 1) return max_height;
            // 如果当前记录的到达该节点的最小路径最大高度比当前路径的 max_height 小，说明该路径不是更优的，跳过
            if(max_height > visit[x][y]) continue;
            
            // 遍历四个方向（右、左、下、上）
            for(int i = 0; i < 4; i++)
            {
                // 计算相邻节点的横、纵坐标
                int a = x + dx[i];
                int b = y + dy[i];
                // 检查相邻节点是否在网格范围内（避免越界）
                if(a >= 0 && a < n && b >= 0 && b < n)
                {
                    // 计算到达相邻节点 (a, b) 时的新路径最大高度：取当前路径最大高度和相邻节点网格高度的较大值
                    int newmax = max(grid[a][b], max_height);
                    // 如果新的路径最大高度比之前记录的到达 (a, b) 的最小路径最大高度小，说明找到更优路径
                    if(newmax < visit[a][b])
                    {
                        // 更新 visit 数组中 (a, b) 位置的最小路径最大高度
                        visit[a][b] = newmax;
                        // 将新的状态（新路径最大高度、相邻节点坐标）加入优先队列，等待后续处理
                        pq.push({newmax, a, b});
                    }
                }
            }
        }
        // 理论上只要网格连通（题目隐含条件），一定会到达终点，这里返回 -1 只是防止编译报错等特殊情况
        return -1;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/swim-in-rising-water/solutions/3735683/shui-wei-shang-sheng-de-yong-chi-zhong-y-uxe7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

取出堆顶节点：

每次取出当前路径最大高度最小的节点 (max_height, x, y)。

终止条件：

若当前节点是终点 (n-1,n-1)，直接返回 max_height（因优先队列特性，此时的 max_height 必为全局最小）。

剪枝优化：

若当前 max_height > visit[x][y]，说明此路径非最优，跳过。

扩展相邻节点：

遍历上下左右四个方向，计算相邻节点 (a,b) 的新路径最大高度 newmax = max(max_height, grid[a][b])。

若 newmax < visit[a][b]，更新 visit[a][b] 并将新状态 {newmax, a, b} 入队。

## 买卖股票的最佳时机

核心思想：

历史最低价格用于确定最佳买入点。

最大利润通过遍历每个可能的卖出点，并计算与历史最低买入点的差值得到。

```C++
class Solution 
{
public:
    int maxProfit(vector<int>& prices) 
    {
        int current_num = INT_MAX, max_profit = 0;
        for(int i = 0; i < prices.size(); i++)
        {
            current_num = min(current_num, prices[i]);
            max_profit = max(max_profit, prices[i] - current_num);
        }
        return max_profit;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solutions/3737289/mai-mai-gu-piao-de-zui-jia-shi-ji-c-by-w-5471/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 小红的ABC

题目链接：[https://ac.nowcoder.com/acm/problem/230720](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fac.nowcoder.com%2Facm%2Fproblem%2F230720)

```C++
#include <iostream>
#include <string>
#include <climits>

using namespace std;

bool isPalindromestring(string str)
{
    int l = 0, r = str.size() - 1;
    while(l < r)
        if(str[l++] != str[r--]) return false;
    return true;  
}

int main()
{
    string str;
    cin >> str;

    int ret = INT_MAX;
    for(int i = 2; i <= str.size(); i++)
        for(int j = 0; j <= str.size() - i; j++)
        {
            string tmp = str.substr(j, i);
            if(isPalindromestring(tmp))
                ret = min(ret, i);
        }
    
    cout << (ret == INT_MAX ? -1 : ret) << endl;

    return 0;
}
```

## 不相邻取数

题目链接： https://www.nowcoder.com/practice/a2be806a0e5747a088670f5dc62cfa1e

```C++
#include <iostream>
#include <vector>
using namespace std;

int main() 
{
    int n;  // n：房屋的数量
    cin >> n;  // 读取房屋数量
    vector<int> nums(n);  // nums[i]：第i间房屋的金额
    for(int i = 0; i < n; i++)
        cin >> nums[i];  // 读取每间房屋的金额

    // 定义dp数组：dp[i]表示偷窃到第i间房屋时的最大金额
    vector<int> dp(n, 0);
    
    // 边界条件1：只有1间房屋时，最大金额就是该房屋的金额
    dp[0] = nums[0];
    
    // 边界条件2：有2间房屋时，只能偷其中金额较大的那间
    if (n >= 2) {  // 补充n=1时的安全判断（原代码隐含n>=2，此处完善）
        dp[1] = max(nums[0], nums[1]);
    }

    // 从第3间房屋开始（i=2），按转移方程计算dp[i]
    for(int i = 2; i < n; i++) {
        // 选择1：不偷第i间房 → 最大金额 = dp[i-1]
        // 选择2：偷第i间房 → 最大金额 = dp[i-2] + nums[i]（因为不能偷i-1）
        // 取两种选择的最大值
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
    }

    // 最终结果：偷窃到最后一间房屋（n-1）时的最大金额
    cout << dp[n - 1] << endl;
    return 0;
}

```

状态 `dp[i]`：表示偷窃到第 `i` 间房屋时，能获得的最大金额。

转移方程：对于第 `i` 间房屋，有两种选择（偷或不偷）：不偷第 i 间房：最大金额 = 偷窃到第 i-1 间房的最大金额（dp[i-1]）。偷第 i 间房：最大金额 = 偷窃到第 i-2 间房的最大金额 + 第 i 间房的金额（dp[i-2] + nums[i]）。取两种选择的最大值，即 dp[i] = max(dp[i-1], dp[i-2] + nums[i])。

## 空调遥控

这道题目看起来不好解决，其实我们只需要转换一下思路：

将我们需要求解的问题：输出一个数字，表示最多有多少队员同时进入训练状态  -> **「在排序数组中寻找最长连续子数组，使子数组中最大元素与最小元素的差不超过 2p」**

采用 **排序 + 双指针** 策略，时间复杂度为 `O(n log n)`（主要来自排序），空间复杂度为 `O(1)`（忽略排序所需空间）。

```C++
#include <iostream>
#include <vector>
#include <algorithm>  // 包含sort排序函数
using namespace std;

int main()
{
    int n, p;  // n：数组长度；p：题目给定参数，用于计算允许的最大差值（2*p）
    cin >> n >> p;  // 读取n和p
    vector<int> nums(n);  // 存储输入的数组
    for(int i = 0; i < n; i++)
        cin >> nums[i];  // 读取数组元素
    
    // 关键：先对数组排序。排序后，子数组的最小元素是nums[l]，最大元素是nums[r]（因数组升序）
    sort(nums.begin(), nums.end());
    
    int ret = 0;  // 记录最长有效子数组的长度（结果）
    int l = 0, r = 0;  // 双指针：l是左边界，r是右边界，维护区间[l, r]
    
    // 右指针r从0遍历到n-1，扩展区间右边界
    while(r < n)
    {
        // 若当前区间的最大-最小 > 2p，说明区间无效，移动左指针l缩小范围
        // 直到区间有效（nums[r] - nums[l] ≤ 2p）
        while(nums[r] - nums[l] > 2 * p) 
            l++;  // 左指针右移，缩小区间
        
        // 此时[l, r]是有效区间，计算长度（r-l+1），更新最长长度ret
        ret = max(ret, r - l + 1);
        
        r++;  // 右指针右移，尝试扩展区间
    }
    
    // 输出最长有效子数组的长度
    cout << ret << endl;
    return 0;
}

```

