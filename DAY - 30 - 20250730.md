# DAY - 30 - 20250730

## 二叉树中的最大路径和

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
private:
    int max_sum = INT_MIN;  // 全局最大路径和，初始化为最小值

public:
    int maxPathSum(TreeNode* root) {
        dfs(root);  // 从根节点开始递归
        return max_sum;  // 返回全局最大值
    }

    // 递归计算以当前节点为根的子树的最大贡献值
    // 贡献值：从当前节点出发，向下延伸的最大路径和（只能选左或右子树）
    int dfs(TreeNode* root) {
        if (root == nullptr) return 0;  // 空节点贡献为0

        // 递归计算左右子树的贡献值，负值则舍弃（取0）
        int left = max(dfs(root->left), 0);
        int right = max(dfs(root->right), 0);

        // 更新全局最大路径和
        // 当前节点作为"转折点"，路径和为：左子树贡献 + 当前节点值 + 右子树贡献
        max_sum = max(max_sum, left + right + root->val);

        // 返回当前节点对父节点的最大贡献值（只能选左或右子树中的一条路径）
        return max(left, right) + root->val;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum/solutions/3732418/er-cha-shu-zhong-de-zui-da-lu-jing-he-c-mlbel/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 在 D 天内送达包裹的能力

```C++
class Solution {
public:
    int shipWithinDays(vector<int>& weights, int days) {
        // 确定二分查找的左右边界
        // 左边界：至少需要能装下最重的单个包裹
        int left = *max_element(weights.begin(), weights.end());
        // 右边界：极端情况是一天运完所有包裹，需要运载能力为所有包裹重量之和
        int right = 0;
        for(auto x : weights) right += x;
        
        // 二分查找最小的可行运载能力
        while(left < right) {
            // 计算中间值，避免整数溢出
            int mid = left + (right - left) / 2;
            // 检查当前运载能力是否可以在days天内运完
            if(canShip(weights, mid, days)) 
                // 如果可行，尝试更小的运载能力
                right = mid;
            else
                // 如果不可行，需要更大的运载能力
                left = mid + 1;
        }
        // 此时left == right，即为最小可行运载能力
        return right;
    }

    // 辅助函数：判断给定运载能力cap是否可以在days天内运完所有包裹
    bool canShip(vector<int>& weights, int cap, int days) {
        // 注意：天数从1开始，因为至少需要1天
        int useday = 1;
        // 当前天已经装载的包裹重量
        int current_sum = 0;
        
        // 遍历每个包裹
        for(auto x : weights) {
            // 如果当前天装载的重量加上当前包裹超过运载能力
            if(current_sum + x > cap) {
                // 需要新的一天来装载当前包裹
                current_sum = x;
                useday++;
            } else {
                // 可以在同一天内装载，累加重量
                current_sum += x;
            }
        }
        
        // 判断实际使用的天数是否小于等于允许的天数
        return useday <= days;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/solutions/3732487/zai-d-tian-nei-song-da-bao-guo-de-neng-l-x44u/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

关键思路：

原题要求找到最小运载能力，使得所有包裹能在 days 天内运输完毕。直接求最小解可能比较麻烦，但是我们可以换一个角度思考：

- 对于任意给定的运载能力cap，能否在days天内运输所有包裹！

这个问题很容易验证：只需要模拟运输过程，累加包裹重量，超过 cap 时增加一天，最后检查总天数是否不超过 days。这就是代码中 canShip 函数的作用。

那这样我们很容易想到暴力的思路：暴力遍历，那具体范围是什么呢？不妨取最大和最小值。最大值：我们一天直接运输完成，这样 cap 即为最大，也就是所有 weights 数组的综合。最小值：理想情况就是每天运输一个货物，但是这样又不对，因为这个获取运输需要按照顺序来的，也就是说，有些情况我们不可能一天只运输一个货物，因为后面的货物质量可能比 cap 大，这样连运输都不行了，所以这里我采用的就是取 weights 数组里最大的元素作为最小值，能保证一定可以运输完毕！

那怎么进行优化呢？对于暴力的思路，我们只需要遍历一遍，看看最小 cap 是多少。我们其实很容易从中发现优化的规律，因为它是线性递增的，有序 + 递增 =》 二分！ 我们这里可以直接使用二分法去快速定位 cap！对于二分法还是很容易实现的，但是需要注意细节问题：下面出现 - 1上面就 +1，否则不加，这里的下面指的是 left 和 right 之间的移动变化，下面指的是 mid 的求法！

## 判断是不是平衡二叉树

```C++
/**
 * struct TreeNode {
 *  int val;
 *  struct TreeNode *left;
 *  struct TreeNode *right;
 *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution
{
public:
    // 对外的接口函数，用于判断二叉树是否是平衡二叉树
    bool IsBalanced_Solution(TreeNode* pRoot)
    {
        // 调用辅助的 dfs 函数，若返回值不是 -1，说明是平衡二叉树，返回 true；否则返回 false
        return dfs(pRoot) != -1; 
    }
 
    // 辅助的深度优先搜索（DFS）函数，兼具计算子树深度和判断是否平衡的功能
    // 返回值：如果以 root 为根节点的子树是平衡的，返回该子树的深度；如果不平衡，返回 -1
    int dfs(TreeNode* root)
    {
        // 如果当前节点是空节点，那么它的深度是 0 ，直接返回 0
        if(root == nullptr) return 0; 
 
        // 递归计算左子树的深度，同时检查左子树是否平衡
        int left = dfs(root->left); 
        // 如果左子树返回 -1 ，说明左子树不平衡，那么当前整棵树也不平衡，直接返回 -1
        if(left == -1) return -1; 
 
        // 递归计算右子树的深度，同时检查右子树是否平衡
        int right = dfs(root->right);
        // 如果右子树返回 -1 ，说明右子树不平衡，那么当前整棵树也不平衡，直接返回 -1
        if(right == -1) return -1; 
 
        // 判断当前节点的左子树和右子树的深度差的绝对值是否大于 1
        // 如果大于 1 ，说明当前节点为根的子树不平衡，返回 -1
        if(abs(left - right) > 1) return -1; 
 
        // 如果当前子树平衡，返回当前子树的深度，深度为左右子树中较大的深度值加 1（加上当前节点这一层）
        return max(left, right) + 1; 
    }
};

作者：程家斌
链接：https://www.nowcoder.com/discuss/782987100080611328?sourceSSR=users
来源：牛客网
```

## 最大子矩阵

```C++
#include <iostream>
using namespace std;
 
// 定义矩阵的最大规模，这里设为 110，可根据实际情况调整
const int N = 110;
// 二维前缀和数组，dp[i][j] 表示从矩阵左上角(1,1)到(i,j)这个矩形区域内所有元素的和
int dp[N][N]; 
 
int main()
{
    // 输入矩阵的边长 n
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= n; j++)
        {
            // 输入矩阵当前位置 (i,j) 的元素值
            cin >> x;
            // 计算二维前缀和，公式推导：
            // dp[i][j] = 上方区域和(dp[i - 1][j]) + 左方区域和(dp[i][j - 1]) - 重复计算的左上角区域和(dp[i - 1][j - 1]) + 当前元素值(x)
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + x;
        }
    }
 
    // 初始化最大子矩阵和，这里用 -127 * N 是一种简单的赋初值方式，
    // 假设矩阵中元素最小可能为 -127（题目未明确说明时的一种保守处理，保证能覆盖所有可能的较小值）
    int ret = -127 * N;
    // 枚举子矩阵的左上角坐标 (x1, y1)
    for(int x1 = 1; x1 <= n; x1++)
        for(int y1 = 1; y1 <= n; y1++)
            // 枚举子矩阵的右下角坐标 (x2, y2)，要求 x2 >= x1，y2 >= y1，保证子矩阵是合法的矩形区域
            for(int x2 = x1; x2 <= n; x2++)
                for(int y2 = y1; y2 <= n; y2++)
                {
                    // 利用二维前缀和公式计算以 (x1,y1) 为左上角，(x2,y2) 为右下角的子矩阵的和
                    // 公式解释：
                    // dp[x2][y2] 是包含该子矩阵的大矩形和；
                    // dp[x1 - 1][y2] 是子矩阵上方区域的和，需要减去；
                    // dp[x2][y1 - 1] 是子矩阵左方区域的和，需要减去；
                    // dp[x1 - 1][y1 - 1] 是上方和左方区域重复减去的部分，需要加回来。
                    int current_sum = dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1];
                    // 更新最大子矩阵和
                    ret = max(ret, current_sum);
                }
 
    // 输出最大子矩阵和
    cout << ret << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/782993354597425152?sourceSSR=users
来源：牛客网
```

**二维前缀和计算**：二维前缀和数组 dp 的构建是解决问题的基础。dp[i][j] 记录了从矩阵左上角 (1,1) 到 (i,j) 这个矩形区域内所有元素的累加和。通过递推公式 dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + x ，可以在 \(O(n^2)\) 的时间复杂度内完成前缀和数组的计算。这样后续计算任意子矩阵的和时，就可以通过前缀和快速推导，无需重复遍历子矩阵元素求和。

**枚举子矩阵**：代码通过四层循环枚举所有可能的子矩阵。外层两层循环 x1 和 y1 确定子矩阵的左上角坐标，内层两层循环 x2 和 y2 确定子矩阵的右下角坐标，并且通过 x2 >= x1 、y2 >= y1 的限制，确保枚举的是合法的、连续的矩形区域。

**子矩阵和计算与更新最大值**：对于每一个枚举到的子矩阵，利用预先计算好的二维前缀和数组，通过公式 dp[x2][y2] - dp[x1 - 1][y2] - dp[x2][y1 - 1] + dp[x1 - 1][y1 - 1] 快速计算出该子矩阵的和。然后将这个和与当前记录的最大和 ret 比较，如果更大就更新 ret 。最终 ret 中保存的就是整个二维矩阵中所有可能子矩阵和的最大值。

## 小葱的01串

```C++
#include <iostream>
using namespace std;
 
// 全局数组，用于统计整个字符串中'0'和'1'的总数量
// count[0] 存储'0'的总数，count[1] 存储'1'的总数
int count[2] = {0};
 
int main()
{
    int n;          // 字符串长度
    string str;     // 输入的二进制字符串（仅包含'0'和'1'）
    cin >> n >> str;
     
    // 统计整个字符串中'0'和'1'的总数量
    for(int i = 0; i < n; i++)
        count[str[i] - '0']++;  // '0'-'0'=0，'1'-'0'=1，分别累加到对应下标
     
    int sum[2] = {0};          // 滑动窗口内'0'和'1'的数量（sum[0]为'0'的数量，sum[1]为'1'的数量）
    int left = 0;              // 滑动窗口左边界
    int right = 0;             // 滑动窗口右边界
    int half = n / 2;          // 目标子串长度（总长度的一半）
    int ret = 0;               // 结果：符合条件的子串对数量
     
    // 滑动窗口遍历字符串，右边界最多到n-2（避免越界，因后续right会自增）
    while(right < n - 1)
    {
        // 将当前右边界字符加入窗口，更新窗口内计数
        sum[str[right] - '0']++;
         
        // 若窗口长度超过目标长度half，移动左边界缩小窗口
        while(right - left + 1 > half)
            sum[str[left++] - '0']--;  // 移除左边界字符，更新计数
         
        // 当窗口长度恰好为half时，检查是否符合条件
        if(right - left + 1 == half)
        {
            // 条件：窗口内'0'的数量是总'0'数的一半，且窗口内'1'的数量是总'1'数的一半
            if(sum[0] == count[0] / 2 && sum[1] == count[1] / 2)
                ret += 2;  // 符合条件则结果+2（因每个有效子串对应一个互补子串）
        }
         
        // 移动右边界，扩大窗口
        right++;
    }
     
    // 输出最终统计的符合条件的子串对数量
    cout << ret << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/783003789203660800?sourceSSR=users
来源：牛客网
```

