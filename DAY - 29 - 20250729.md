# DAY - 29 - 20250729

## 对称二叉树

```C++
class Solution {
public:
    // 判断二叉树是否对称
    bool isSymmetric(TreeNode* root) {
        // 从根节点的左右子树开始检查
        return Symmetric(root->left, root->right);
    }
    
    // 递归检查两个节点是否镜像对称
    bool Symmetric(TreeNode* l, TreeNode* r) {
        // 情况1：一个节点为空，另一个不为空，不对称
        if (l == nullptr && r != nullptr || l != nullptr && r == nullptr) 
            return false;
        
        // 情况2：两个节点都为空，对称
        if (l == nullptr && r == nullptr) 
            return true;
        
        // 情况3：节点值不相等，不对称
        if (l->val != r->val) 
            return false;
        
        // 递归检查子树：
        // 1. 左节点的左子树 与 右节点的右子树 是否对称
        // 2. 左节点的右子树 与 右节点的左子树 是否对称
        return Symmetric(l->left, r->right) && Symmetric(l->right, r->left);
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/symmetric-tree/solutions/3731439/dui-cheng-er-cha-shu-c-by-wu-guan-feng-y-8d2q/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

关键逻辑分析

递归终止条件：

当两个节点中一个为空，另一个不为空时，返回 false（结构不对称）。

当两个节点都为空时，返回 true（空树视为对称）。

值比较：

若两个节点的值不相等，直接返回 false。

递归检查子树：

左子树的左子节点需要与右子树的右子节点对称。

左子树的右子节点需要与右子树的左子节点对称。

## 二叉搜索树中第K小的元素

```C++
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int count = 0;     // 记录当前遍历到的节点序号（升序）
        int result = 0;    // 存储最终结果（第k小的值）
        dfs(root, count, k, result);
        return result;
    }

    // 中序遍历辅助函数
    // count: 引用传递，记录当前遍历的节点数
    // k: 目标序号
    // result: 引用传递，存储第k小的值
    void dfs(TreeNode* root, int& count, int k, int& result) {
        // 终止条件：节点为空时返回
        if (root == nullptr) return;
        
        // 1. 递归遍历左子树
        dfs(root->left, count, k, result);
        
        // 2. 处理当前节点
        // 中序遍历的位置，count累加
        count++;
        // 当count等于k时，说明当前节点就是第k小的元素
        if (count == k) {
            result = root->val;
            // 注意：这里没有提前返回，会继续遍历右子树
            // 但由于result已记录，后续修改不会影响最终结果
        }
        
        // 3. 递归遍历右子树
        dfs(root->right, count, k, result);
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/kth-smallest-element-in-a-bst/solutions/3731517/er-cha-sou-suo-shu-zhong-di-kxiao-de-yua-3yce/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 打怪

```C++
#include <iostream>
using namespace std;
 
int h, a, H, A;
int t;
 
int fun()
{
    if(a >= H) return -1;
     
    int m = (H / a) + (H % a == 0 ? 0 : 1);
    int n = m - 1;
    int x = n * A; // 杀死一只怪，玩家会掉多少血！
    return h / x - (h % x == 0 ? 1 : 0);
}
 
int main()
{
    cin >> t;
    while(t--)
    {
        cin >> h >> a >> H >> A;
        cout << fun() << endl;
    }
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/782973471264468992?sourceSSR=users
来源：牛客网
```

利用数学向上取整法减少循环次数！

## 字符串分类

```C++
#include <iostream>
#include <string>
#include <algorithm>
#include <unordered_set>
using namespace std;
 
int main()
{
    unordered_set<string> hash;
    string str;
    int n;
    cin >> n;
 
    while(n--)
    {
        cin >> str;
        sort(str.begin(), str.end());
        hash.insert(str);
    }
    cout << hash.size() << endl;
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/782975402586226688?sourceSSR=users
来源：牛客网
```

直接排序之后，使用哈希去重即可！

##  城市群数量

```C++
#include <vector>
class Solution
{
    // 访问标记数组：vis[i]为true表示第i个节点已被访问
    // 大小210是预设的最大节点数，适用于节点数量不超过210的场景
    bool vis[210] = {false};
 
public:
    // 计算图中连通分量的数量
    // 参数m：图的邻接矩阵表示，m[i][j]为非0值表示节点i和j相连
    int citys(vector<vector<int> >& m)
    {
        int n = m.size();  // 获取节点数量（邻接矩阵的行数）
        int ret = 0;       // 记录连通分量的数量，初始为0
 
        // 遍历所有节点
        for(int i = 0; i < n; i++)
        {
            // 如果当前节点未被访问，说明发现了一个新的连通分量
            if(!vis[i])
            {
                ret++;              // 连通分量数量加1
                dfs(m, i);          // 从当前节点开始DFS，标记整个连通分量的节点为已访问
            }
        }
        return ret;  // 返回连通分量的总数
    }
 
    // 深度优先搜索(DFS)：从pos节点出发，标记所有与其连通的节点
    // 参数m：邻接矩阵；pos：当前搜索的节点索引
    void dfs(vector<vector<int>>& m, int pos)
    {
        vis[pos] = true;  // 标记当前节点为已访问
 
        // 遍历所有节点，寻找与当前节点pos相连且未被访问的节点
        for(int i = 0; i < m.size(); i++)
        {
            // 条件：节点i未被访问，且节点pos与节点i相连（m[pos][i]非0）
            if(!vis[i] && m[pos][i])
            {
                dfs(m, i);  // 递归访问节点i，继续深入搜索
            }
        }
    }
};

作者：程家斌
链接：https://www.nowcoder.com/discuss/782980345913237504?sourceSSR=users
来源：牛客网
```

这段代码的核心功能是**计算一个无向图中连通分量的数量**。连通分量指的是图中 "相互连通的节点组成的最大子集"（即子集中的任意两个节点都能通过路径连接，且子集外的节点无法与子集内节点连接）。

1. 数据结构与变量vis[210]：布尔数组，用于标记节点是否被访问过，避免重复处理同一节点邻接矩阵m：通过二维数组表示图，m[i][j]的值非零时，表示节点i和节点j之间有边相连
2. 主函数citys的逻辑遍历所有节点，对每个未访问的节点：计数器ret加 1（发现新的连通分量）调用dfs函数，递归标记该连通分量的所有节点为 "已访问"最终返回ret，即连通分量的总数
3. 辅助函数dfs的逻辑标记当前节点pos为已访问遍历所有节点，找到与pos相连且未访问的节点，递归调用dfs继续搜索作用是 "扩散式" 标记整个连通分量，确保每个连通分量只被计数一次