# DAY - 31 - 20250731

## 除自身以外数组的乘积

```C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        
        // 前缀积数组：prefix[i] 表示 nums[0] 到 nums[i-1] 的乘积
        vector<int> prefix(n, 1);  // 初始化为1，因为空数组的乘积为1
        int product = 1;  // 累积乘积
        for(int i = 1; i < n; i++) {
            product *= nums[i - 1];  // 计算前 i-1 个元素的乘积
            prefix[i] = product;     // 存储前缀积
        }

        // 后缀积数组：suffix[i] 表示 nums[i+1] 到 nums[n-1] 的乘积
        vector<int> suffix(n, 1);  // 初始化为1，因为空数组的乘积为1
        product = 1;  // 重置累积乘积
        for(int i = n - 2; i >= 0; i--) {
            product *= nums[i + 1];  // 计算从 i+1 到末尾的乘积
            suffix[i] = product;     // 存储后缀积
        }

        // 结果数组：每个位置等于前缀积乘以后缀积
        vector<int> ret;
        for(int i = 0; i < n; i++) {
            ret.push_back(prefix[i] * suffix[i]);  // 除自身外的乘积 = 前缀积 × 后缀积
        }

        return ret;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/product-of-array-except-self/solutions/3732527/chu-zi-shen-yi-wai-shu-zu-de-cheng-ji-c-1dofh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 缺失的第一个正数

```C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        
        // 步骤1: 预处理，将所有不在[1, n]范围内的数替换为n+1
        // 这样这些无效数字不会影响后续的标记过程
        for(int i = 0; i < n; i++)
            if(nums[i] > n || nums[i] < 1)
                nums[i] = n + 1;
        
        // 步骤2: 标记存在的数字
        // 对于每个在[1, n]范围内的数x，将索引x-1的位置标记为负数
        // 这样可以利用符号位作为哈希表，标记该数字是否存在
        for(int i = 0; i < n; i++) {
            int x = abs(nums[i]);  // 取绝对值，因为该位置可能已被标记为负
            if(x <= n) 
                nums[x - 1] = -abs(nums[x - 1]);  // 标记为负数，表示x存在
        }

        // 步骤3: 查找第一个正数
        // 如果某个位置i是正数，说明数字i+1没有被标记，即缺失
        for(int i = 0; i < n; i++)
            if(nums[i] > 0) 
                return i + 1;
                
        // 如果所有位置都是负数，说明[1, n]都存在，返回n+1
        return n + 1;
    }
};

作者：无关风月
链接：https://leetcode.cn/problems/first-missing-positive/solutions/3735655/que-shi-de-di-yi-ge-zheng-shu-c-by-wu-gu-ac40/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 笨小猴

直接模拟就行，注意一下细节：

```C++
#include <iostream>
#include <string>
using namespace std;
 
int nums[26];
 
bool isprime(int n)
{
    if(n < 2) return false;
    if(n == 2) return true;
    for(int i = 3; i * i <= n; i++)
        if(n % i == 0) return false;
 
    return true;
}
 
int main()
{
    int max_cnt = 0, min_cnt = 101;
    string str;
    cin >> str;
 
    for(int i = 0; i < str.size(); i++)
        if(str[i] >= 'a' && str[i] <= 'z')
            nums[str[i] - 'a']++;
 
    for(int i = 0; i < 26; i++)
        if(nums[i])
        {
            max_cnt = max(max_cnt, nums[i]);
            min_cnt = min(min_cnt, nums[i]);
        }
 
    if(isprime(max_cnt - min_cnt))
    {
        cout << "Lucky Word" << endl;
        cout << max_cnt - min_cnt << endl;
    }
    else
    {
        cout << "No Answer" << endl;
        cout << 0 << endl;
    }
 
    return 0;
}


作者：程家斌
链接：https://www.nowcoder.com/discuss/784777839240282112?sourceSSR=users
来源：牛客网
```

##  主持人调度（一）

```C++
class Solution
{
public:
    bool hostschedule(vector<vector<int> >& schedule)
    {
        vector<vector<int>> ret;
        sort(schedule.begin(), schedule.end());
        ret.push_back(schedule[0]);
        for(int i = 1; i < schedule.size(); i++)
        {
            auto x = ret.back();
            int rborder = x[1], lborder = schedule[i][0];
            if(lborder >= rborder)
            {
                ret.pop_back();
                ret.push_back({x[0], schedule[i][1]});
            }
            else ret.push_back(schedule[i]);
        }
        return ret.size() == 1 ? true : false;
    }
};

作者：程家斌
链接：https://www.nowcoder.com/discuss/784783082497769472?sourceSSR=users
来源：牛客网
```

排完序之后处理就行，如果需要输出整个集合，那就是ret。力扣上是需要全部输出整个集合的。

 [https://leetcode.cn/problems/merge-intervals/](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fleetcode.cn%2Fproblems%2Fmerge-intervals%2F) - 力扣-合并区间

## 分割等和子集

```C++
#include <iostream>
#include <vector>
#include <algorithm> // 包含max函数
using namespace std;
 
int main()
{
    int n, sum = 0, max_num = 0; // n：数组长度；sum：数组总和；max_num：数组中最大元素
    cin >> n; // 读取数组长度
    vector<int> nums(n); // 初始化存储数组的容器
     
    // 1. 读取数组元素，同时计算总和sum和最大元素max_num
    for(int i = 0; i < n; i++)
    {
        cin >> nums[i]; // 读取元素
        max_num = max(max_num, nums[i]); // 更新最大元素
        sum += nums[i]; // 累加计算总和
    }
 
    // 2. 预处理判断1：若总和为奇数，直接无法分割（两个相等的整数和必为偶数）
    if(sum % 2 != 0)
    {
        cout << "false" << endl;
        return 0;
    }
 
    // 3. 计算目标和target（总和的一半）
    int target = sum / 2;
     
    // 4. 预处理判断2：若最大元素 > target，无法分割（该元素无法被任何子集包含）
    if(max_num > target)
    {
        cout << "false" << endl;
        return 0;
    }
 
    // 5. 动态规划：定义dp[j]表示「能否从数组中选出若干元素，使其和为j」
    vector<bool> dp(target + 1, false); // 大小为target+1，初始全为false
    dp[0] = true; // 基准情况：和为0的子集一定存在（空集）
 
    // 6. 遍历每个元素，更新dp数组（0-1背包逻辑）
    for(int i = 0; i < n; i++) // 遍历每个元素（每个元素只能选一次）
        // 从target倒序遍历到nums[i]：避免同一元素被重复选择（0-1背包核心）
        for(int j = target; j >= nums[i]; j--)
            // 状态转移：若能组成和为j-nums[i]的子集，加上当前元素nums[i]就能组成和为j的子集
            dp[j] = dp[j] || dp[j - nums[i]];
 
    // 7. 最终判断：若dp[target]为true，说明存在和为target的子集，即能分割
    cout << (dp[target] ? "true" : "false");
    return 0;
}

作者：程家斌
链接：https://www.nowcoder.com/discuss/784795050273263616?sourceSSR=users
来源：牛客网
```

预处理优化：总和为奇数时直接返回 false（数学必然性）。最大元素超过 target 时返回 false（该元素无法被任何子集包含，否则子集和会超过 target）。

动态规划设计：dp[j] 的含义：是否存在子集和为 j。初始状态 dp[0] = true：空集的和为 0，是必然存在的。

0-1 背包的倒序遍历：内层循环从 target 倒序到 nums[i]，确保每个元素仅被考虑一次（避免重复选择）。状态转移逻辑：若 dp[j - nums[i]] 为 true（存在和为 j - nums[i] 的子集），则加上当前元素 nums[i] 后，dp[j] 也为 true。

